
# 메시지와 인터페이스 
> 객체지향 어플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고 받는 메시지여 이는 객체지향 설계자로 성장하기 위한 첫걸음이다.

## 협력과 메시지 

### 클라이언트 - 서버모델
- 객체가 독립적으로 수행할 수 있는 것 보다 더 큰 책임을 수행하기 위해 다른 객체와 협력해야 한다. 

### 메시지와 메시지 전송
- 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다. 
- 메세지 전송자를 클라이언트, 메시지 수신자를 서버라고 부르기도 한다. 
- 메시지는 오퍼레이션명과 인자로 구성되며, 메시지 전송은 메시지 수신자를 추가한 것이다.
    - isSatisfiedBy(screening) -> 이와 같은 것이 메시지이며 
    - condition.isSatisfiedBy(screening) -> 메시지 전송이다. 
  ![스크린샷 2023-11-25 오후 3.25.57.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-25%20%EC%98%A4%ED%9B%84%203.25.57.png)
### 퍼블릭 인터페이스와 오퍼레이션
- 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 부른다. 
- 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다.

### 시그니처 
- 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 시그니처 라고 부른다. 
- 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이며 메서드는 이 시그니처에 구현을 더한 것이다.


## 인터페이스와 설계 품질 
- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다.
- 추상적인 인터페이스를 설계하면서 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다. 
    - 메시지를 먼저 선택하면서 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지하는 것 
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법은 아래와 같다. 
    1. 디미터 법칙
    2. 묻지 말고 시켜라 
    3. 의도를 드러내는 인터페이스
    4. 명령-쿼리 분리

### 디미터 법칙 
>협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 제안된 원칙 
- 객체의 내부 구조에 강합게 결합되지 않게 협력 경로를 제한해라 
- 어떤 것도 다른 객체에게 보여주지 말고, 다른 객체의 구현에 의존하지 마라 
- 오직 하나의 도트만을 사용해라 

#### 디미터 법칙을 위반한 코드 
```java
screening.getMovie().getDiscountConditions();
```
- 위와 같은 연쇄적으로 메시지를 전송하는 것을 **기차 충돌**이라고부른다.
- 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을때 나타나는 전형적인 형태며 메시지 전송자는 수신자의 내부 정보를 자세히 알게된다. 그러므로 **캡슐화가 무너지며 내부 구현에 강하게 결합된다.**

#### 디미터 법칙을 지킨 코드 
```java
screening.calculate(audienceCount);
```
- 객체가 자기 자신을 책임지는 자율적인 존재를 만도록 해라 
- 위와 같은 코드를 지키게되면 더 이상 메시지 수신자의 내부 구조에 관해 자세히 알지 모르게 된다.
- 하지만 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다.
### 묻지 말고 시켜라 
- 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시켜서 해라 
- 묻지 말고 시켜라 원칙에 따르도록 메시지를 결정하다 보면 자연스럽게 높은 응집도를 가진 클래스를 얻을 수 있다. 
- **만일, 묻지 말고 시켜라 원칙과, 디미터 법칙을 활용해 내부의 상태를 묻는 오퍼레이션이 있다면 더 나은 방법은 없는지. 고민해봐라.  내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재 
  한다면 객체가 책임져야 하는 행동이 객체 외부로 누수가 된 것이다.**
- 강조하면 객체가 수신할 메시지를 결정하는데 있어서 매 순간 묻지 말고 시켜라 원칙과 디미터 법칙을 머릿속에 잘 새겨라.
- 스타일을 따르지 않을 경우엔 기차 충돌, 일련의 getter들이 기차의 객차처럼 상호연결되어 보이는 코드가 만들어진다.
### 의도를 드러내는 인터페이스
####  메서드가 작업을 어떻게 수행하는지를 나타내라
```java
public class PeriodCondition {
    public boolean isSatisfiedByPeriod(Screening screening){}
}

public class SequenceCondition {
    public boolean isSatisfiedByPeriod(Screening screening){}
}
```
- 위 코드의 스타일은 메서드에 대해 제대로 커뮤니케이션하지 못한다. 
    1.  클라이언트 관점에서 모두 할인 조건을 판단하는 동일한 작업을 수행한다는 점
    2. 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행한다는 사실을 알아채기 어렵다.
- 메서드 수준에서의 캡슐화 위반 
  1. 할인 여부를 판단하는 방법이 변경되면 메서드의 이름 역시 변경해야 한다.
  2. 메서드 이름을 변경하는 것은 메시지를 전송하는 클라이언트의 코드도 함께 변경해야 한다.

#### 메서드의 이름을 짓는 방법은 '어떻게' 가 아닌 _'무엇을'_
- 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해라 
- 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들어라 
- 결과적으로 협력하는 클라이언트 의도에 부합하도록 메서드의 이름을 짓게 된다. 
- 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여해라 
- 의도를 분명하게 표현하는 이름을 갖도록 하고, setter를 사용하지마라 
  1. 무엇을하는건지 정확하게 알수가 없다. 


### 원칙의 함정 
> 설계는 트레이드오프의 산물이다. 설계를 적절하게 할 수 있는 것이 숙련자와 초보자를 구분하는 가장 중요한 기준이다. 
> 
- 원칙을 맹목적으로 추종하지마라 
- 원칙에 정당성을 부여하려고 억지로 끼워 맞추려 하지마라 
- 일관성을 지키도록 유지해라 

## 명령-쿼리 분리 원칙
> 질문이 답변을 수정해서는 안된다.

- 루틴
  - 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
- 프로시저와 함수 
  - 정해진 절차에 따라 내부의 상태를 변경하는 프로시저, 어떤 절차에 따라 필요한 값을 계산해서 반환하는 함수 
- 객체의 상태를 수정하는 오퍼레이션을 명령이라 부른다. 
- 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다.

#### 명령-쿼리 분리 원칙의 요지는 오퍼러이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리중 하나여야하며 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다.
- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다. 

### 반복 일정의 명령과 쿼리 분리하기 

```java
public class Event {
    public boolean isSatisfied(RecurringSchedule schedule) {
        if (from.getDayOfWeek() != schedule.getDayOfWeek() ||
                !from.toLocalTime().equals(schedule.getFrom()) ||
                !duration.equals(schedule.getDuration())) {
            reschedule(schedule); // 이부분 
            return false;
        }
        return true;
    }
}
```
- 위의 코드에 문제점은 이러하다 명령과 쿼리를 명확하게 분리하지 못한 점이다. 
- isSatisfied가 명령과 쿼리의 두 가지 역할을 동시에 수행했기 때문이다. 

### 문제 해결방안
> 명령과 쿼리를 명확하게 구분해라 
```java
public class Event {
  public boolean isSatisfied(RecurringSchedule schedule) {
    if (from.getDayOfWeek() != schedule.getDayOfWeek() ||
            !from.toLocalTime().equals(schedule.getFrom()) ||
            !duration.equals(schedule.getDuration())) {
      return false;
    }
    return true;
  }
}
```
- 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워지니 주의해라 
- 명령과 쿼리를 분리하게 되면 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해진다.

## 명령-쿼리 분리와 참조 투명성
> 참조 투명성은 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성
- 함수는 내부에 부수효과를 포함할 경우 동일한 인자를 전달하더라도 부수효과에 의해 그 결괏값이 매번 달라질 수 있다. -> 부수효과
- 참조 투명성은 버그가 적고, 디버깅이 용이하며 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다.
- 참조 투명성을 사용하면 모든 함수를 이미 알고 있는 하나의 결과값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
- 모든 곳에서 함수의 결과값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
- 명령-쿼리 분리 원칙을 사용해서 부수효과를 가지는 명령으로부터 균열을 줄여라.


## 책임에 초점을 맞춰라 
> 인터페이스를 설계하는 아주 쉬운 방법은 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택해라 
> 
- 디미터 법칙: 협력이라는 문맥안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다. 수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문이다. 
- 묻지 말고 시켜라: 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다. 클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.
- 의도를 드러내는 인터페이스: 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다. 당연히 그 이름에는 클라이언트가 무엇을 원하는지 , 그 의도가 분명하게 
  드러날 수밖에 없다. 
- 명령-쿼리 분리 원칙: 메시지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미한다. 객체가 단순히 어떤 이릉ㄹ 해야 하는지뿐만 아니라 협력 속에서 객체의 상태를 
  이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다. 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리해라 
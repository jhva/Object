# 디자인 패턴과 프레임워크
### 디자인 패턴 
- 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴이라고 부른다.
- 목적은 설계를 재사용하는 것 이며 패턴을 익히고 나면 변경의 방향과 주기를 이해하는 것만으로도 필요한 역할과 책임, 역할들 의 협력 방식을 떠올릴수 있다.

### 프레임워크
- 프레임워크는 설계와 코드를 함께 재사용하기 위한 것이다. 
- 프레임워크는 다양한 환경에서 테스트를 거친 견고한 구현 코드를 쉽고 빠르게 재사용할 수 있으며 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.

_디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법이다_

## 디자인 패턴과 설계 재사용 

### 소프트웨어 패턴 
- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다
- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 자식을 다른 사람과 의사소통할 수 있다
- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다
- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다

### 패턴 분류 
> 패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄의 4가지로 분류하는 것
- 아키텍처 패턴과 이디엄은 기술적인 문제를 해결하는데 초점이 맞춰져있다.
#### 아키텍처 패턴
- 미리 정의된 서브시스템을 제공하고, 각 서브시스템들의 책임을 정의하며 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다. 디자인 패턴과 마찬가지로 프로그래밍 언어나 
  프로그래밍 패러다임에 독립적이다.
#### 이디엄
- 이디엄은 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴이며 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다. 
#### 분석 패턴 
- 도메인 내의 개념적인 문제를 해결하는데 초점을 맞춘다. 
- 업무 모델링시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다. 
- 단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수도 있다. 

### 패턴과 책임-주도 설계 
> 객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 일이다.
- 책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재 사용성 등 다양한 요소들의 트레이드오프를 통해 결정된다

#### GOF 디자인 패턴 
- Strategy 패턴: 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합 
- Bridge 패턴: 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만든다. 
- Observer 패턴: 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.

#### Composite 패턴 
![스크린샷 2023-12-19 오후 2.07.50.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-19%20%EC%98%A4%ED%9B%84%202.07.50.png)
- 위 사진은 Composite 패턴의 일반적인 구조이다
- 패턴의 구성 요소인 Component, Composite, Leaf는 클래스가 아니라 협력에 참여하는 객체들의 역할이다. 
- Component는 역할이기 때문에 Componet가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 Componenet의 역할을 수행할 수 있다. 
![스크린샷 2023-12-19 오후 2.11.32.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-19%20%EC%98%A4%ED%9B%84%202.11.32.png)
- 역할은 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합이다 
- 하나의 객체가 세 가지 역할 모두를 수행하더라도 문제가 없다 
![스크린샷 2023-12-19 오후 2.11.41.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-19%20%EC%98%A4%ED%9B%84%202.11.41.png)
- 다수의 클래스가 동일한 역할을 구현할 수도 있다.

_디자인 패턴의 구성요소가 클래스와 메서드가 아니라 역할과 책임이라는 사실을 이해하는 것이 중요하고, 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기 할때는 역할, 책임, 협력의 관점에서 유사성을 
공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아니라는 점을 이해하는 것 역시 중요하다._

### 캡슐화와 디자인 패턴 

#### Strategy 패턴 기반 영화 예매 시스템 설계 
![스크린샷 2023-12-19 오후 2.15.36.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-19%20%EC%98%A4%ED%9B%84%202.15.36.png)
- 영화에 적용될 할인 정책의 종류는 Movie가 참조하는 DiscountPolicy의 서브클래스가 무엇이냐에 따라 결정된다.
- strategy 패턴을 이용하면 Movie와 DiscountPolicy 사이의 결합도를 낮게 유지할 수 있기 때문에 런타임에 알고리즘을 변경할 수 있다 .

#### Template method 패턴 
> 변경하지 않는 부분은 부모 클래스로, 변하는 부분은 자식 클래스로 분리함으로써 변경을 캡슐화하기 위해 합성 관계가 아닌 상속 관계를 사용하는 것을 Template method 패턴이라고 한다 

![스크린샷 2023-12-19 오후 2.17.33.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-19%20%EC%98%A4%ED%9B%84%202.17.33.png)
> 부모 클래스의 calculateFee 메서드 안에서 추상 메서드인 calculateDiscountAmount를 호출하고 자식 클래스들이 이 메서드를 오버라이딩해서 변하는 부분을 구현하는 것 
- 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화할 수 있는 디자인 패턴이다. 
- 런타임에 객체의 알고리즘을 변경하는 것은 불가능하지만, 교체와 같은 요구사항이 없다면 상대적으로 strategy 패턴보다 복잡도를 낮출 수 있다는 장점이 있다. 


#### Decorator 패턴 
> 핸드폰 과금 시스템 설계는 Decorator 패턴 기반으로 한다.
![스크린샷 2023-12-19 오후 2.30.46.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-19%20%EC%98%A4%ED%9B%84%202.30.46.png)
- Decorator 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용함 
- 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화 할 수 있다.


### 패턴은 출발점이다. 
> 많은 전문가들은 널리 요구되는 유연성이나 공통적으로 발견되는 특정한 설계 이슈를 해결하기 위해 적절한 디자인 패턴을 이용해 설계를 시작하는데 이는 안좋은 방법이다. 
- 패턴은 설계의 목표가 돼서는 안 된다
- 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않으면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정해라 
- 패턴이 제시하는 구조를 맹목적으로 따르는 것은 불필요하게 복잡하고, 난해하며, 유지보수하기 어려운 시스템을 낳는다.
- 타당한 이유 없이 패턴을 적용하면 패턴에 익숙한 사람들의 경우에는 설계의 의도를 이해하지 못하게 되고, 패턴을 알지 못하는 사람들은 불필요하게 복잡한 설계를 따라가느라 시간을 낭비하게 된다.
- 정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다.
- 패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화돼야 한다.
- 패턴을 가장효과적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩터링하는 것이라고 이야기한다. 

## 프레임워크와 코드 재사용 
프레임워크는 '추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템전 체 혹은 일부를 구현해 놓은 재사용 가능한 설계' 또는 '애플리케이션 개발자가 현재의 요구사항에 맞게 커스터 마이징 
할 수 있는 애플리케이션의 골격' 을 의미한다. 

### 코드 재사용 대 설계 재사용
- 재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다. 
- 다양한 도메인에 재사용 가능한 컴포넌트라는 개념은 비현실적이다.
- 프레임워크는 코드를 재사용하면서 설계 아이디어를 재사용한다.

### 상위 정책과 하위 정책으로 패키지 분리하기 
> 프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화라고 할 수 있다.
- 추상 클래스와 인터페이스가 일관성 있는 협력을 만든다. 
  1. 협력을 일관성 있고 유연하게 만들기 위해서는 추상화를 이용해 변경을 캡슐화 해라 
  2. 협력을 구현하는 코드 안의 의존성은 가급적이면 추상 클래스나 인터페이스와 같은 추상화를 향하도록 작성해라

![스크린샷 2023-12-19 오후 5.32.14.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-19%20%EC%98%A4%ED%9B%84%205.32.14.png)
> 대부분의 의존성이 추상화를 향하는 일관성 있는 협력 
- 객체지향 이전의 구조적인 설계와 같은 전통적인 소프트웨어 개발 방법의 경우 상위 레벨 모듈이 하위 레벨 모듈에, 그리고 상위 정책이 구체적인 세부적인 사항에 의존하도록 소프트웨어를 구성한다 
- 상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다. 
- 부모가 하위에 의존하게 되면 부모에 모든 경우도 항상 함께 존재해야 하기 떄문에 부모의 재사용성이 낮아진다. 재사용성을 높이려면 의존성 역전 원칙에 맞게 상위 정책과 세부 사항 모두 추상화에 의존하게 만들어라
- 의존성 역전 원칙의 관점에서 세부 사항은 '변경'을 의미한다. 
- 프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 '배포 단위'로 분리해야 한다 
![스크린샷 2023-12-19 오후 5.53.33.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-19%20%EC%98%A4%ED%9B%84%205.53.33.png)
![스크린샷 2023-12-19 오후 5.53.22.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-19%20%EC%98%A4%ED%9B%84%205.53.22.png)
- 더 나아가 상위를 구현하고 있는 패키지가 충분히 안정적이고 성숙했다면 하위 패키지로부터 분리하여 별도의 배포단위로 만들수 있다 .
- 상위  패키지와 하위  패키지를 물리적으로 완전히 분리하고 나면 상위 정책 패키지를 여러 애플리케이션에서 재사용할 수 있는 기반이 마련된다. 이로서 재사용 가능한 로직을 구현한 프레임워크가 완성되는 것 

### 제어 역전 원리 
> 객체지향 설계의 재사용성은 개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름으로부터 나온다.
> 
- 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 매커니즘이다.
- 의존성 역전은 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.
- 의존성 역전 원리에 따라 구축되지 않은 시스템은 협력 흐름을 재사용할 수도 없으며 변경에 유연하게 대처할 수도 없다.
- 의존성 역전 원리가 적절하게 지켜지지 않고 있다면 변경을 적절하게 수용할 수 없는 하향식의 절차적인 코드가 존재할 수밖에 없다. 
- 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. 즉 의존성을 역전시키면 제어 흐름의 주체 역시 역전된다. 이를 제어 역전 원리, 또는 할리우드 원리라고 한다.